{"version":3,"file":"glitch/glitchcore.js","sources":["glitch/glitch.c","glitch/expr.h"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6aA;;AClMA;AASA;;;;;;;AARA;;;;;;;;AADA;;;;;;;;;AAKA;;;;;AAIA;AAEA;AAEA;;;;;ADqLA;ACzLA;;;;;;;AARA;;;;;;;;AADA;;;;;;;;;AAKA;;;;;AAIA;AAEA;AAEA;;;;;ADsLA;AC1LA;;;;;;;AARA;;;;;;;;AADA;;;;;;;;;AAKA;;;;;AAIA;AAEA;AAEA;;;;;ADuLA;AC3LA;;;;;;;AARA;;;;;;;AADA;;;;;;;;;AAKA;;;;AAIA;AAEA;AAAA;AAAA;AAAA;AAEA;;;;ADwLA;AACA;;ACsCA;AAAA;AAAA;;;;;;;;AA0CA;AAyCA;AA/TA;;;;;;;;;;;;AA4IA;AAVA;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;;;;;;;;;;;;;AASA;;;;;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/MA;;;;;;;;;;;AADA;;;;;;;;;;;;;;AAsOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;AAvOA;;;;;;;;;AADA;;;;;;;;;;;;;;;;;AA8OA;;;;;;;;;;;;;;;;;;;;;;;;;;AAjDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsHA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;;;;;;;;;;;;;AA9eA;AACA;;;;;;;;;;;;;;AAqfA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAtfA;AACA;;;;;;;;;;;;;AAgfA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;;;;AAlfA;AACA;;;;;;;;;;;;;;AAkfA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;;;;;;;;;;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AAzUA;;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;AA2UA;AAAA;AAAA;AAAA;AAEA;;;;;;;AA9gBA;AACA;;;;;;;;;;;AA6gBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAMA;;;;AACA;;;;;;;AAvhBA;;;;AAEA;AACA;;;;;;;;;;;AAIA;AACA;;;AAqhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA9WA;AACA;AAEA;AA8WA;;AACA;AAAA;AAAA;AAAA;AACA;AAliBA;;;;;AAEA;AACA;;AAIA;AACA;;;;;;;AA0hBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA/VA;;;;;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAjMA;AACA;;;;;;;;;;;;;;AAmiBA;AAAA;;;;;;;;;;;;AAhYA;;;;;;;AADA;;;;;;;;;;;AAyDA;AASA;;;;;;;AARA;;;;;;;AADA;;;;;;;;;;AAKA;;;;AAIA;AAEA;AAAA;AACA;AACA;;;AA+VA;AAAA;AAAA;AAAA;AAGA;AA7kBA;;;;;AAEA;AACA;;AAIA;AACA;;;;;;;AAqkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvaA;;;;;;;;AADA;;;;;;;;;;;AAuYA;;;;;;;AArbA;;;;;AA4cA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnBA;;;;;;;;;;;;;;;;;AA1YA;;;;;;;AADA;;;;;;;;;;;;;AA6ZA;;;;;;;;;;;;;;;;;;AAlBA;;;;;;;;;;;;;;;;;AA1YA;;;;;;;AADA;;;;;;;;;;;;;AA6ZA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5ZA;;;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;AADA;;;;;;;;;;;;;;;;;AA+ZA;;;;;;;;;;;;;AA9ZA;;;;;;;AADA;;;;;;;;;;;;;;;;;;;;;;;AACA;;;;;;;AADA;;;;;;;;;;;;;;;;;;AA6YA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AD7IA;ACtaA;;;;;;AAEA;AACA;;AAIA;AACA;;;;;;;;AA2iBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAjjBA;AACA;;;;;;;;;;;;;;AAwjBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;AAAA;AAAA;;;;;;;;;;AASA;AACA;AAQA;;AADA;AACA;AACA;;ADhMA;AAAA;;ACwLA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;;;ADhMA;AAAA;;AAHA;AAAA;;ACwNA;AACA;;ADxNA;;AAEA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","sourcesContent":["#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"glitch.h\"\n#include \"tr808.h\"\n\n#include \"expr.h\"\n\nstatic int SAMPLE_RATE = 48000;\n\n#define PI 3.1415926\n\nstatic float denorm(float x) { return x * 127 + 128; }\nstatic float arg(vec_expr_t args, int n, float defval) {\n  if (vec_len(&args) < n + 1) {\n    return defval;\n  }\n  return expr_eval(&vec_nth(&args, n));\n}\n\nstruct osc_context {\n  float freq;\n  float w;\n};\n\ntypedef vec(float) vec_float_t;\n\nstruct seq_context {\n  int init;\n  float mul;\n  int beat;\n  float t;\n\n  float value;\n  vec_float_t values;\n};\n\nstruct env_context {\n  int init;\n  vec_float_t d;\n  vec_float_t e;\n  int t;\n  int segment;\n};\n\nstruct mix_context {\n  int init;\n  vec_float_t values;\n};\n\nstruct iir_context {\n  float value;\n};\n\nstatic float lib_s(struct expr_func *f, vec_expr_t args, void *context) {\n  return denorm(sin(arg(args, 0, 0) * PI / 128));\n}\n\nstatic float lib_r(struct expr_func *f, vec_expr_t args, void *context) {\n  return rand() * arg(args, 0, 255) / RAND_MAX;\n}\n\nstatic float lib_l(struct expr_func *f, vec_expr_t args, void *context) {\n  if (arg(args, 0, 0)) {\n    return log2f(arg(args, 0, 0));\n  }\n  return 0;\n}\n\nstatic float lib_a(struct expr_func *f, vec_expr_t args, void *context) {\n  float index = arg(args, 0, NAN);\n  if (isnan(index)) {\n    return NAN;\n  }\n  int len = vec_len(&args) - 1;\n  if (len == 0) {\n    return 0;\n  }\n  int i = (int) floor(index + len) % len;\n  i = (i + len) % len;\n  return arg(args, i+1, 0);\n}\n\nstatic int scales[][13] = {\n  {7, 0, 2, 4, 5, 7, 9, 11, 0, 0, 0, 0}, // ionian, major scale\n  {7, 0, 2, 3, 5, 7, 9, 10, 0, 0, 0, 0}, // dorian\n  {7, 0, 1, 3, 5, 7, 8, 10, 0, 0, 0, 0}, // phrygian\n  {7, 0, 2, 4, 6, 7, 9, 11, 0, 0, 0, 0}, // lydian\n  {7, 0, 2, 4, 5, 7, 9, 10, 0, 0, 0, 0}, // mixolydian\n  {7, 0, 2, 3, 5, 7, 8, 10, 0, 0, 0, 0}, // aeolian, natural minor scale\n  {7, 0, 1, 3, 5, 6, 8, 10, 0, 0, 0, 0}, // locrian\n  {7, 0, 2, 3, 5, 7, 8, 11, 0, 0, 0, 0}, // harmonic minor scale\n  {7, 0, 2, 3, 5, 7, 9, 11, 0, 0, 0, 0}, // melodic minor scale\n  {5, 0, 2, 4, 7, 9, 0, 0, 0, 0, 0, 0}, // major pentatonic\n  {5, 0, 3, 5, 7, 10, 0, 0, 0, 0, 0, 0}, // minor pentatonic\n  {6, 0, 3, 5, 6, 7, 10, 0, 0, 0, 0}, // blues\n  {6, 0, 2, 4, 6, 8, 10, 0, 0, 0, 0}, // whole tone scale\n  {8, 0, 1, 3, 4, 6, 7, 9, 10, 0, 0, 0}, // octatonic\n  {12, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, // chromatic is a fallback scale\n};\n\nstatic float lib_scale(struct expr_func *f, vec_expr_t args, void *context) {\n  float note = arg(args, 0, 0);\n  float scale = arg(args, 1, 0);\n  if (isnan(scale) || isnan(note)) {\n    return NAN;\n  }\n  if (scale < 0 || scale > 14) {\n    scale = 14;\n  }\n  int len = scales[(int) scale][0];\n  int n = (int) note;\n  int transpose = n / len * 12;\n  n = (n + len) % len;\n  n = (n + len) % len;\n  return scales[(int) scale][n+1] + transpose;\n}\n\nstatic float lib_hz(struct expr_func *f, vec_expr_t args, void *context) {\n  return pow(2, arg(args, 0, 0) / 12) * 440;\n}\n\nstatic float lib_osc(struct expr_func *f, vec_expr_t args, void *context) {\n  struct osc_context *osc = (struct osc_context *) context;\n  float freq = arg(args, 0, NAN);\n  if (!isnan(freq) && (osc->freq == 0 || osc->w > 1.0/osc->freq)) {\n    osc->w = osc->w - floor(osc->w);\n    osc->freq = freq;\n  }\n  osc->w += 1.0 / SAMPLE_RATE;\n  float w = osc->w * osc->freq;\n  if (isnan(freq)) {\n    return NAN;\n  }\n  if (strncmp(f->name, \"sin\", 4) == 0) {\n    return denorm(sin(w * 2 * PI));\n  } else if (strncmp(f->name, \"tri\", 4) == 0) {\n    w = w + 0.25f;\n    return denorm(-1 + 4 * fabs(w - roundf(w)));\n  } else if (strncmp(f->name, \"saw\", 4) == 0) {\n    return denorm(2 * (w - roundf(w)));\n  } else if (strncmp(f->name, \"sqr\", 4) == 0) {\n    w = w - floor(w);\n    return denorm(w < arg(args, 1, 0.5) ? 1 : -1);\n  } else if (strncmp(f->name, \"fm\", 3) == 0) {\n    float mf1 = arg(args, 1, 0);\n    float mi1 = arg(args, 2, 0);\n    float mf2 = arg(args, 3, 0);\n    float mi2 = arg(args, 4, 0);\n    float mf3 = arg(args, 5, 0);\n    float mi3 = arg(args, 6, 0);\n\n    float tau = osc->w * 2 * PI;\n    float v3 = mi3 * sin(tau * (osc->freq * mf3));\n    float v2 = mi2 * sin(tau * (osc->freq * mf2 + v3));\n    float v1 = mi1 * sin(tau * (osc->freq * mf1 + v3));\n    return denorm(sin(tau * (osc->freq + v1 + v2)));\n  }\n  return 0;\n}\n\nstatic float lib_seq(struct expr_func *f, vec_expr_t args, void *context) {\n  struct seq_context *seq = (struct seq_context *) context;\n  if (!seq->init) {\n    seq->mul = 1;\n    seq->init = 1;\n  }\n  float beatlen = SAMPLE_RATE / (arg(args, 0, NAN) / 60) * seq->mul;\n  if (isnan(beatlen)) {\n    return NAN;\n  }\n  int t = seq->t;\n  seq->t = seq->t + 1;\n  int len = vec_len(&args) - 1;\n  if (len <= 0) {\n    return (t == 0 ? NAN : 0);\n  }\n  int i = seq->beat % len;\n  if (seq->t >= beatlen) {\n    seq->t = 0;\n    seq->beat++;\n  }\n\n  struct expr *e = &vec_nth(&args, i+1);\n  if (strncmp(f->name, \"seq\", 4) == 0) {\n    if (t == 0) {\n      vec_free(&seq->values);\n      if (e->type == OP_COMMA) {\n\tseq->mul = expr_eval(&vec_nth(&e->op.args, 0));\n\te = &vec_nth(&e->op.args, 1);\n\tif (e->type == OP_COMMA) {\n          while (e->type == OP_COMMA) {\n            vec_push(&seq->values, expr_eval(&vec_nth(&e->op.args, 0)));\n\t    e = &vec_nth(&e->op.args, 1);\n          }\n\t  vec_push(&seq->values, expr_eval(e));\n          return NAN;\n\t}\n      } else {\n\tseq->mul = 1;\n      }\n      seq->value = expr_eval(e);\n      return NAN;\n    }\n\n    len = vec_len(&seq->values);\n    if (len == 0) {\n      return seq->value;\n    } else {\n      int n = len - 1;\n      int i = (int) (len * t / beatlen);\n      float from = vec_nth(&seq->values, i);\n      float to = vec_nth(&seq->values, i + 1);\n      float k = (t / beatlen - i / n) * n;\n      return from + (to - from) * k;\n    }\n  } else if (strncmp(f->name, \"loop\", 5) == 0) {\n    if (e->type == OP_COMMA) {\n      seq->mul = expr_eval(&vec_nth(&e->op.args, 0));\n      e = &vec_nth(&e->op.args, 1);\n    } else {\n      seq->mul = 1;\n    }\n    float value = expr_eval(e);\n    return t == 0 ? NAN : value;\n  }\n  return 0;\n}\n\nstatic float lib_env(struct expr_func *f, vec_expr_t args, void *context) {\n  struct env_context *env = (struct env_context *) context;\n\n  // Zero arguments = zero signal level\n  // One argument = unmodied signal value\n  if (vec_len(&args) < 2) {\n    return arg(args, 0, 128);\n  }\n  // Last argument is signal value\n  float v = arg(args, vec_len(&args) - 1, NAN);\n\n  if (!env->init) {\n    env->init = 1;\n    if (vec_len(&args) == 2) {\n      vec_push(&env->d, 0.0625 * SAMPLE_RATE);\n      vec_push(&env->d, arg(args, 0, NAN) * SAMPLE_RATE);\n      vec_push(&env->e, 1);\n      vec_push(&env->e, 0);\n    } else {\n      vec_push(&env->d, arg(args, 0, NAN) * SAMPLE_RATE);\n      vec_push(&env->e, 1);\n      for (int i = 1; i < vec_len(&args) - 1; i = i + 2) {\n\tvec_push(&env->d, arg(args, i, NAN) * SAMPLE_RATE);\n\tif (i + 1 < vec_len(&args) - 1) {\n\t  vec_push(&env->e, arg(args, i+1, NAN));\n\t} else {\n\t  vec_push(&env->e, 0);\n\t}\n      }\n    }\n  }\n  if (isnan(v)) {\n    env->segment = 0;\n    env->t = 0;\n    return NAN;\n  }\n  env->t++;\n  if (env->segment < vec_len(&env->d)) {\n    if (env->t > vec_nth(&env->d, env->segment)) {\n      env->t = 0;\n      env->segment++;\n    }\n  } else {\n    return 128; // end of envelope\n  }\n  float prevAmp = (env->segment == 0 ? 0 : vec_nth(&env->e, env->segment - 1));\n  float amp = vec_nth(&env->e, env->segment);\n  return (v - 128) * (prevAmp + (amp - prevAmp) *\n      (env->t / vec_nth(&env->d, env->segment))) + 128;\n}\n\nstatic float lib_mix(struct expr_func *f, vec_expr_t args, void *context) {\n  struct mix_context *mix = (struct mix_context *) context;\n  if (!mix->init) {\n    for (int i = 0; i < vec_len(&args); i++) {\n      vec_push(&mix->values, 0);\n    }\n    mix->init = 1;\n  }\n  float v = 0;\n  for (int i = 0; i < vec_len(&args); i++) {\n    struct expr *e = &vec_nth(&args, i);\n    float vol = 1;\n    if (e->type == OP_COMMA) {\n      vol = expr_eval(&vec_nth(&e->op.args, 0));\n      e = &vec_nth(&e->op.args, 1);\n    }\n    float sample = expr_eval(e);\n    if (isnan(sample)) {\n      sample = vec_nth(&mix->values, i);\n    }\n    vec_nth(&mix->values, i) = sample;\n    v = v + vol * (sample - 128) / 127;\n  }\n  if (vec_len(&args) > 0) {\n    v = v / sqrtf(vec_len(&args));\n    v = ((v < -1) ? -1 : v);\n    v = ((v > 1) ? 1 : v);\n    return denorm(v);\n  }\n  return 128;\n}\n\nstatic float lib_iir(struct expr_func *f, vec_expr_t args, void *context) {\n  struct iir_context *iir = (struct iir_context *) context;\n  float cutoff = arg(args, 1, 200);\n  float signal = arg(args, 0, NAN);\n  if (isnan(signal) || isnan(cutoff)) {\n    return NAN;\n  }\n  float wa = tan(PI * cutoff / SAMPLE_RATE);\n  float a = wa / (1.0 + wa);\n  iir->value = iir->value + (signal - iir->value) * a;\n  return iir->value;\n}\n\nstatic float lib_tr808(struct expr_func *f, vec_expr_t args, void *context) {\n  struct osc_context *osc = (struct osc_context *) context;\n\n  float drum = arg(args, 0, NAN);\n  float vol = arg(args, 1, 1);\n  /*let len = TR808Samples.length;*/\n  if (isnan(drum) || isnan(vol)) {\n    osc->w = 0;\n    return NAN;\n  }\n\n  static unsigned char *samples[] = {\n    tr808_bd_wav,\n    tr808_sn_wav,\n    tr808_mt_wav,\n    tr808_mc_wav,\n    tr808_rs_wav,\n    tr808_cl_wav,\n    tr808_cb_wav,\n    tr808_oh_wav,\n    tr808_hh_wav,\n  };\n  static unsigned int len[] = {\n    tr808_bd_wav_len,\n    tr808_sn_wav_len,\n    tr808_mt_wav_len,\n    tr808_mc_wav_len,\n    tr808_rs_wav_len,\n    tr808_cl_wav_len,\n    tr808_cb_wav_len,\n    tr808_oh_wav_len,\n    tr808_hh_wav_len,\n  };\n  static int N = sizeof(samples)/sizeof(*samples);\n\n  int index = (((int) drum % N) + N) % N;\n  unsigned char *sample = samples[index];\n  if (osc->w * 2 + 0x80 + 1 < len[index]) {\n    unsigned char hi = sample[0x80 + (int) osc->w * 2+1];\n    unsigned char lo = sample[0x80 + (int) osc->w * 2];\n    int sign = hi & (1 << 7);\n    int v = (hi << 8) | lo;\n    if (sign) {\n      v = -v + 0x10000;\n    }\n    float x =  v * 1.0 / 0x7fff;\n    osc->w = osc->w + 1;\n    return x * vol * 127 + 128;\n  }\n  return 128;\n}\n\nstatic float lib_user_sample(struct expr_func *f, vec_expr_t args, void *context) {\n  return 0;\n}\n\nstatic struct expr_func glitch_funcs[] = {\n    {\"s\", lib_s, 0},\n    {\"r\", lib_r, 0},\n    {\"l\", lib_l, 0},\n    {\"a\", lib_a, 0},\n    {\"scale\", lib_scale, 0},\n    {\"hz\", lib_hz, 0},\n\n    {\"sin\", lib_osc, sizeof(struct osc_context)},\n    {\"tri\", lib_osc, sizeof(struct osc_context)},\n    {\"saw\", lib_osc, sizeof(struct osc_context)},\n    {\"sqr\", lib_osc, sizeof(struct osc_context)},\n    {\"fm\", lib_osc, sizeof(struct osc_context)},\n    {\"tr808\", lib_tr808, sizeof(struct osc_context)},\n\n    {\"loop\", lib_seq, sizeof(struct seq_context)},\n    {\"seq\", lib_seq, sizeof(struct seq_context)},\n\n    {\"env\", lib_env, sizeof(struct env_context)},\n\n    {\"mix\", lib_mix, sizeof(struct mix_context)},\n\n    {\"lpf\", lib_iir, sizeof(struct iir_context)},\n    {NULL, NULL, 0},\n};\n\nstruct glitch *glitch_create() {\n  struct glitch *g = calloc(1, sizeof(struct glitch));\n  return g;\n}\n\nvoid glitch_sample_rate(int rate) {\n  SAMPLE_RATE = rate;\n}\n\nvoid glitch_destroy(struct glitch *g) {\n  expr_destroy(g->e, &g->vars);\n  free(g);\n}\n\nvoid glitch_xy(struct glitch *g, float x, float y) {\n  g->x->value = x;\n  g->y->value = y;\n}\n\nint glitch_compile(struct glitch *g, const char *s, size_t len) {\n  if (!g->init) {\n    g->t = expr_var(&g->vars, \"t\", 1);\n    g->x = expr_var(&g->vars, \"x\", 1);\n    g->y = expr_var(&g->vars, \"y\", 1);\n    g->bpm = expr_var(&g->vars, \"bpm\", 3);\n    g->init = 1;\n  }\n  struct expr *e = expr_create(s, len, &g->vars, glitch_funcs);\n  if (e == NULL) {\n    return -1;\n  }\n  expr_destroy(g->next_expr, NULL);\n  g->next_expr = e;\n  return 0;\n}\n\nfloat glitch_eval(struct glitch *g) {\n  int apply_next = 1;\n  /* If BPM is given - apply changes on the next beat */\n  if (g->bpm->value > 0) {\n    g->measure++;\n    if (g->measure < SAMPLE_RATE * 60 / g->bpm->value) {\n      apply_next = 0;\n    } else {\n      g->measure = 0;\n    }\n  } else {\n    g->measure = 0;\n  }\n  if (apply_next && g->next_expr != NULL) {\n    expr_destroy(g->e, NULL);\n    g->e = g->next_expr;\n    g->next_expr = NULL;\n  }\n  float v = expr_eval(g->e);\n  if (!isnan(v)) {\n    g->last_sample = fmod(fmod(v, 256)+256, 256)/128 - 1;\n  }\n  g->t->value = roundf(g->frame * 8000.0f / SAMPLE_RATE);\n  g->frame++;\n  return g->last_sample;\n}\n","#ifndef EXPR_H\n#define EXPR_H\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <ctype.h> /* for isspace */\n#include <math.h>  /* for pow */\n\n/*\n * Simple expandable vector implementation\n */\nstatic int vec_expand(char **buf, int *length, int *cap, int memsz) {\n  if (*length + 1 > *cap) {\n    void *ptr;\n    int n = (*cap == 0) ? 1 : *cap << 1;\n    ptr = realloc(*buf, n * memsz);\n    if (ptr == NULL) {\n      return -1; /* allocation failed */\n    }\n    *buf = (char *)ptr;\n    *cap = n;\n  }\n  return 0;\n}\n#define vec(T)                                                                 \\\n  struct {                                                                     \\\n    T *buf;                                                                    \\\n    int len;                                                                   \\\n    int cap;                                                                   \\\n  }\n#define vec_len(v) ((v)->len)\n#define vec_unpack(v)                                                          \\\n  (char **)&(v)->buf, &(v)->len, &(v)->cap, sizeof(*(v)->buf)\n#define vec_push(v, val)                                                       \\\n  (vec_expand(vec_unpack(v)) ? -1 : ((v)->buf[(v)->len++] = (val), 0), 0)\n#define vec_nth(v, i) (v)->buf[i]\n#define vec_peek(v) (v)->buf[(v)->len - 1]\n#define vec_pop(v) (v)->buf[--(v)->len]\n#define vec_free(v) (free((v)->buf), (v)->buf = NULL, (v)->len = (v)->cap = 0)\n#define vec_foreach(v, var, iter)                                              \\\n  if ((v)->len > 0)                                                            \\\n    for ((iter) = 0; (iter) < (v)->len && (((var) = (v)->buf[(iter)]), 1);     \\\n         ++(iter))\n\n/*\n * Expression data types\n */\nstruct expr;\nstruct expr_func;\n\nenum expr_type {\n  OP_UNKNOWN,\n  OP_UNARY_MINUS,\n  OP_UNARY_LOGICAL_NOT,\n  OP_UNARY_BITWISE_NOT,\n\n  OP_POWER,\n  OP_MULTIPLY,\n  OP_DIVIDE,\n  OP_REMAINDER,\n\n  OP_PLUS,\n  OP_MINUS,\n\n  OP_SHL,\n  OP_SHR,\n\n  OP_LT,\n  OP_LE,\n  OP_GT,\n  OP_GE,\n  OP_EQ,\n  OP_NE,\n\n  OP_BITWISE_AND,\n  OP_BITWISE_OR,\n  OP_BITWISE_XOR,\n\n  OP_LOGICAL_AND,\n  OP_LOGICAL_OR,\n\n  OP_ASSIGN,\n  OP_COMMA,\n\n  OP_CONST,\n  OP_VAR,\n  OP_FUNC,\n};\n\ntypedef vec(struct expr) vec_expr_t;\ntypedef float (*exprfn_t)(struct expr_func *f, vec_expr_t args, void *context);\n\nstruct expr {\n  enum expr_type type;\n  union {\n    struct {\n      float value;\n    } num;\n    struct {\n      float *value;\n    } var;\n    struct {\n      vec_expr_t args;\n    } op;\n    struct {\n      struct expr_func *f;\n      vec_expr_t args;\n      void *context;\n    } func;\n  };\n};\n\nstruct expr_string {\n  const char *s;\n  int n;\n};\nstruct expr_arg {\n  int oslen;\n  int eslen;\n  vec_expr_t args;\n};\n\ntypedef vec(struct expr_string) vec_str_t;\ntypedef vec(struct expr_arg) vec_arg_t;\n\nstatic int expr_is_unary(enum expr_type op) {\n  return op == OP_UNARY_MINUS || op == OP_UNARY_LOGICAL_NOT ||\n         op == OP_UNARY_BITWISE_NOT;\n}\n\nstatic int expr_is_binary(enum expr_type op) {\n  return !expr_is_unary(op) && op != OP_CONST && op != OP_VAR &&\n         op != OP_FUNC && op != OP_UNKNOWN;\n}\n\nstatic int expr_is_left_assoc(enum expr_type op) {\n  return expr_is_binary(op) && op != OP_ASSIGN && op != OP_POWER &&\n         op != OP_COMMA;\n}\n\nstatic struct {\n  const char *s;\n  const enum expr_type op;\n} OPS[] = {\n  {\"-u\", OP_UNARY_MINUS},\n  {\"!u\", OP_UNARY_LOGICAL_NOT},\n  {\"^u\", OP_UNARY_BITWISE_NOT},\n  {\"**\", OP_POWER},\n  {\"*\", OP_MULTIPLY},\n  {\"/\", OP_DIVIDE},\n  {\"%\", OP_REMAINDER},\n  {\"+\", OP_PLUS},\n  {\"-\", OP_MINUS},\n  {\"<<\", OP_SHL},\n  {\">>\", OP_SHR},\n  {\"<\", OP_LT},\n  {\"<=\", OP_LE},\n  {\">\", OP_GT},\n  {\">=\", OP_GE},\n  {\"==\", OP_EQ},\n  {\"!=\", OP_NE},\n  {\"&\", OP_BITWISE_AND},\n  {\"|\", OP_BITWISE_OR},\n  {\"^\", OP_BITWISE_XOR},\n  {\"&&\", OP_LOGICAL_AND},\n  {\"||\", OP_LOGICAL_OR},\n  {\"=\", OP_ASSIGN},\n  {\",\", OP_COMMA},\n\n  /* These are used by lexer and must be ignored by parser, so we put\n     them at the end */\n  {\"-\", OP_UNARY_MINUS},\n  {\"!\", OP_UNARY_LOGICAL_NOT},\n  {\"^\", OP_UNARY_BITWISE_NOT},\n};\n\nstatic enum expr_type expr_op(const char *s, size_t len, int unary) {\n  for (int i = 0; i < sizeof(OPS) / sizeof(OPS[0]); i++) {\n    if (strlen(OPS[i].s) == len && strncmp(OPS[i].s, s, len) == 0 &&\n        (unary == -1 || expr_is_unary(OPS[i].op) == unary)) {\n      return OPS[i].op;\n    }\n  }\n  return OP_UNKNOWN;\n}\n\nstatic float expr_parse_number(const char *s, size_t len) {\n  char *endp = NULL;\n  float num = strtof(s, &endp);\n  if (endp - s == len) {\n    return num;\n  } else {\n    return NAN;\n  }\n}\n\n/*\n * Functions TODO\n */\nstruct expr_func {\n  char *name;\n  exprfn_t f;\n  size_t ctxsz;\n};\n\nstatic struct expr_func *expr_func(const char *s, size_t len,\n                                   struct expr_func *funcs) {\n  for (struct expr_func *f = funcs; f->name; f++) {\n    if (strlen(f->name) == len && strncmp(f->name, s, len) == 0) {\n      return f;\n    }\n  }\n  return NULL;\n}\n\n/*\n * Variables\n */\nstruct expr_var {\n  float value;\n  struct expr_var *next;\n  char name[];\n};\n\nstruct expr_var_list {\n  struct expr_var *head;\n};\n\nstatic struct expr_var *expr_var(struct expr_var_list *vars, const char *s,\n                                 size_t len) {\n  struct expr_var *v = NULL;\n  if (len == 0 || isdigit(*s)) {\n    return NULL;\n  }\n  for (v = vars->head; v; v = v->next) {\n    if (strlen(v->name) == len && strncmp(v->name, s, len) == 0) {\n      return v;\n    }\n  }\n  v = (struct expr_var *)calloc(1, sizeof(struct expr_var) + len + 1);\n  if (v == NULL) {\n    return NULL; /* allocation failed */\n  }\n  v->next = vars->head;\n  v->value = 0;\n  strncpy(v->name, s, len);\n  v->name[len] = '\\0';\n  vars->head = v;\n  return v;\n}\n\nstatic int to_int(float x) {\n  if (isnan(x)) {\n    return 0;\n  } else if (isinf(x) != 0) {\n    return INT_MAX * isinf(x);\n  } else {\n    return (int)x;\n  }\n}\n\nstatic float expr_eval(struct expr *e) {\n  float n;\n  switch (e->type) {\n  case OP_UNARY_MINUS:\n    return -(expr_eval(&e->op.args.buf[0]));\n  case OP_UNARY_LOGICAL_NOT:\n    return !(expr_eval(&e->op.args.buf[0]));\n  case OP_UNARY_BITWISE_NOT:\n    return ~(to_int(expr_eval(&e->op.args.buf[0])));\n  case OP_POWER:\n    return powf(expr_eval(&e->op.args.buf[0]), expr_eval(&e->op.args.buf[1]));\n  case OP_MULTIPLY:\n    return expr_eval(&e->op.args.buf[0]) * expr_eval(&e->op.args.buf[1]);\n  case OP_DIVIDE:\n    return expr_eval(&e->op.args.buf[0]) / expr_eval(&e->op.args.buf[1]);\n  case OP_REMAINDER:\n    return fmodf(expr_eval(&e->op.args.buf[0]), expr_eval(&e->op.args.buf[1]));\n  case OP_PLUS:\n    return expr_eval(&e->op.args.buf[0]) + expr_eval(&e->op.args.buf[1]);\n  case OP_MINUS:\n    return expr_eval(&e->op.args.buf[0]) - expr_eval(&e->op.args.buf[1]);\n  case OP_SHL:\n    return to_int(expr_eval(&e->op.args.buf[0]))\n           << to_int(expr_eval(&e->op.args.buf[1]));\n  case OP_SHR:\n    return to_int(expr_eval(&e->op.args.buf[0])) >>\n           to_int(expr_eval(&e->op.args.buf[1]));\n  case OP_LT:\n    return expr_eval(&e->op.args.buf[0]) < expr_eval(&e->op.args.buf[1]);\n  case OP_LE:\n    return expr_eval(&e->op.args.buf[0]) <= expr_eval(&e->op.args.buf[1]);\n  case OP_GT:\n    return expr_eval(&e->op.args.buf[0]) > expr_eval(&e->op.args.buf[1]);\n  case OP_GE:\n    return expr_eval(&e->op.args.buf[0]) >= expr_eval(&e->op.args.buf[1]);\n  case OP_EQ:\n    return expr_eval(&e->op.args.buf[0]) == expr_eval(&e->op.args.buf[1]);\n  case OP_NE:\n    return expr_eval(&e->op.args.buf[0]) != expr_eval(&e->op.args.buf[1]);\n  case OP_BITWISE_AND:\n    return to_int(expr_eval(&e->op.args.buf[0])) &\n           to_int(expr_eval(&e->op.args.buf[1]));\n  case OP_BITWISE_OR:\n    return to_int(expr_eval(&e->op.args.buf[0])) |\n           to_int(expr_eval(&e->op.args.buf[1]));\n  case OP_BITWISE_XOR:\n    return to_int(expr_eval(&e->op.args.buf[0])) ^\n           to_int(expr_eval(&e->op.args.buf[1]));\n  case OP_LOGICAL_AND:\n    n = expr_eval(&e->op.args.buf[0]);\n    if (n != 0) {\n      n = expr_eval(&e->op.args.buf[1]);\n      if (n != 0) {\n        return n;\n      }\n    }\n    return 0;\n  case OP_LOGICAL_OR:\n    n = expr_eval(&e->op.args.buf[0]);\n    if (n != 0) {\n      return n;\n    } else {\n      n = expr_eval(&e->op.args.buf[1]);\n      if (n != 0) {\n        return n;\n      }\n    }\n    return 0;\n  case OP_ASSIGN:\n    n = expr_eval(&e->op.args.buf[1]);\n    if (e->op.args.buf[0].type == OP_VAR) {\n      *e->op.args.buf[0].var.value = n;\n    }\n    return n;\n  case OP_COMMA:\n    expr_eval(&e->op.args.buf[0]);\n    return expr_eval(&e->op.args.buf[1]);\n  case OP_CONST:\n    return e->num.value;\n  case OP_VAR:\n    return *e->var.value;\n  case OP_FUNC:\n    return e->func.f->f(e->func.f, e->func.args, e->func.context);\n  default:\n    return NAN;\n  }\n}\n\n#define EXPR_TOP (1 << 0)\n#define EXPR_TOPEN (1 << 1)\n#define EXPR_TCLOSE (1 << 2)\n#define EXPR_TNUMBER (1 << 3)\n#define EXPR_TWORD (1 << 4)\n#define EXPR_TDEFAULT (EXPR_TOPEN | EXPR_TNUMBER | EXPR_TWORD)\n\n#define EXPR_UNARY (1 << 5)\n\nstatic int expr_next_token(const char *s, size_t len, int *flags) {\n  int i = 0;\n  if (len == 0) {\n    return 0;\n  }\n  char c = s[0];\n  if (isspace(c)) {\n    while (i < len && isspace(s[i])) {\n      i++;\n    }\n    return i;\n  } else if (isdigit(c)) {\n    if ((*flags & EXPR_TNUMBER) == 0) {\n      return -1; // unexpected number\n    }\n    *flags = EXPR_TOP | EXPR_TCLOSE;\n    while ((c == '.' || isdigit(c)) && i < len) {\n      i++;\n      c = s[i];\n    }\n    return i;\n  } else if (isalpha(c)) {\n    if ((*flags & EXPR_TWORD) == 0) {\n      return -2; // unexpected word\n    }\n    *flags = EXPR_TOP | EXPR_TOPEN | EXPR_TCLOSE;\n    while ((isalpha(c) || isdigit(c) || c == '_') && i < len) {\n      i++;\n      c = s[i];\n    }\n    return i;\n  } else if (c == '(' || c == ')') {\n    if (c == '(' && (*flags & EXPR_TOPEN) != 0) {\n      *flags = EXPR_TNUMBER | EXPR_TWORD | EXPR_TOPEN | EXPR_TCLOSE;\n    } else if (c == ')' && (*flags & EXPR_TCLOSE) != 0) {\n      *flags = EXPR_TOP | EXPR_TCLOSE;\n    } else {\n      return -3; // unexpected parenthesis\n    }\n    return 1;\n  } else {\n    if ((*flags & EXPR_TOP) == 0) {\n      if (expr_op(&c, 1, 1) == OP_UNKNOWN) {\n        return -4; // missing expected operand\n      }\n      *flags = EXPR_TNUMBER | EXPR_TWORD | EXPR_TOPEN | EXPR_UNARY;\n      return 1;\n    } else {\n      int found = 0;\n      while (!isalpha(c) && !isdigit(c) && !isspace(c) && c != '_' &&\n             c != '(' && c != ')' && i < len) {\n        if (expr_op(s, i + 1, 0) != OP_UNKNOWN) {\n          found = 1;\n        } else if (found) {\n          break;\n        }\n        i++;\n        c = s[i];\n      }\n      if (!found) {\n        return -5; // unknown operator\n      }\n      *flags = EXPR_TNUMBER | EXPR_TWORD | EXPR_TOPEN;\n      return i;\n    }\n  }\n}\n\n#define EXPR_PAREN_ALLOWED 0\n#define EXPR_PAREN_EXPECTED 1\n#define EXPR_PAREN_FORBIDDEN 2\n\nstatic int expr_bind(const char *s, size_t len, struct expr_func *funcs,\n                     vec_expr_t *es) {\n  enum expr_type op = expr_op(s, len, -1);\n  if (op == OP_UNKNOWN) {\n    return -1;\n  }\n\n  if (expr_is_unary(op)) {\n    if (vec_len(es) < 1) {\n      return -1;\n    }\n    struct expr arg = vec_pop(es);\n    struct expr unary = {(enum expr_type)0};\n    unary.type = op;\n    vec_push(&unary.op.args, arg);\n    vec_push(es, unary);\n  } else {\n    if (vec_len(es) < 2) {\n      return -1;\n    }\n    struct expr b = vec_pop(es);\n    struct expr a = vec_pop(es);\n    struct expr binary = {(enum expr_type)0};\n    binary.type = op;\n    if (op == OP_ASSIGN && a.type != OP_VAR) {\n      return -1; /* Bad assignment */\n    }\n    vec_push(&binary.op.args, a);\n    vec_push(&binary.op.args, b);\n    vec_push(es, binary);\n  }\n  return 0;\n}\n\nstatic struct expr *expr_create(const char *s, size_t len,\n                                struct expr_var_list *vars,\n                                struct expr_func *funcs) {\n  float num;\n  struct expr_var *v;\n\n  vec_expr_t es = {0};\n  vec_str_t os = {0};\n  vec_arg_t as = {0};\n\n  int flags = EXPR_TDEFAULT;\n  int paren = EXPR_PAREN_ALLOWED;\n  for (;;) {\n    int n = expr_next_token(s, len, &flags);\n    if (n == 0) {\n      break;\n    } else if (n < 0) {\n      return NULL;\n    }\n    const char *tok = s;\n    s = s + n;\n    len = len - n;\n    if (flags & EXPR_UNARY) {\n      if (n == 1) {\n        switch (*tok) {\n        case '-':\n          tok = \"-u\";\n          break;\n        case '^':\n          tok = \"^u\";\n          break;\n        case '!':\n          tok = \"!u\";\n          break;\n        default:\n          return NULL;\n        }\n        n = 2;\n      }\n    }\n    if (isspace(*tok)) {\n      continue;\n    }\n    int paren_next = EXPR_PAREN_ALLOWED;\n    if (n == 1 && *tok == '(') {\n      if (paren == EXPR_PAREN_EXPECTED) {\n        struct expr_string str = {\"{\", 1};\n        vec_push(&os, str);\n        struct expr_arg arg = {vec_len(&os), vec_len(&es), {0}};\n        vec_push(&as, arg);\n      } else if (paren == EXPR_PAREN_ALLOWED) {\n        struct expr_string str = {\"(\", 1};\n        vec_push(&os, str);\n      } else {\n        return NULL; // Bad call\n      }\n    } else if (paren == EXPR_PAREN_EXPECTED) {\n      return NULL; // Bad call\n    } else if (n == 1 && *tok == ')') {\n      int minlen = (vec_len(&as) > 0 ? vec_peek(&as).oslen : 0);\n      while (vec_len(&os) > minlen && *vec_peek(&os).s != '(' &&\n             *vec_peek(&os).s != '{') {\n        struct expr_string str = vec_pop(&os);\n        if (expr_bind(str.s, str.n, funcs, &es) == -1) {\n          return NULL;\n        }\n      }\n      if (vec_len(&os) == 0) {\n        return NULL; // Bad parens\n      }\n      struct expr_string str = vec_pop(&os);\n      if (str.n == 1 && *str.s == '{') {\n        str = vec_pop(&os);\n        struct expr_func *f = expr_func(str.s, str.n, funcs);\n        struct expr_arg arg = vec_pop(&as);\n        if (vec_len(&es) > arg.eslen) {\n          vec_push(&arg.args, vec_pop(&es));\n        }\n        struct expr bound_func = {(enum expr_type)0};\n        bound_func.type = OP_FUNC;\n        bound_func.func.f = f;\n        bound_func.func.args = arg.args;\n        if (f->ctxsz > 0) {\n          void *p = calloc(1, f->ctxsz);\n          if (p == NULL) {\n            return NULL; /* allocation failed */\n          }\n          bound_func.func.context = p;\n        }\n        vec_push(&es, bound_func);\n      }\n      paren_next = EXPR_PAREN_FORBIDDEN;\n    } else if (!isnan(num = expr_parse_number(tok, n))) {\n      struct expr numexpr = {OP_CONST, num};\n      vec_push(&es, numexpr);\n      paren_next = EXPR_PAREN_FORBIDDEN;\n    } else if (expr_func(tok, n, funcs) != NULL) {\n      struct expr_string str = {tok, n};\n      vec_push(&os, str);\n      paren_next = EXPR_PAREN_EXPECTED;\n    } else if (expr_op(tok, n, -1) != OP_UNKNOWN) {\n      enum expr_type op = expr_op(tok, n, -1);\n      struct expr_string o2 = {0};\n      if (vec_len(&os) > 0) {\n        o2 = vec_peek(&os);\n      }\n      for (;;) {\n        if (n == 1 && *tok == ',' && vec_len(&os) > 0) {\n          struct expr_string str = vec_peek(&os);\n          if (str.n == 1 && *str.s == '{') {\n            struct expr e = vec_pop(&es);\n            vec_push(&vec_peek(&as).args, e);\n            break;\n          }\n        }\n        enum expr_type type2 = expr_op(o2.s, o2.n, -1);\n        if (!(type2 != OP_UNKNOWN &&\n              ((expr_is_left_assoc(op) && op >= type2) || op > type2))) {\n          struct expr_string str = {tok, n};\n          vec_push(&os, str);\n          break;\n        }\n\n        if (expr_bind(o2.s, o2.n, funcs, &es) == -1) {\n          return NULL;\n        }\n        vec_pop(&os);\n        if (vec_len(&os) > 0) {\n          o2 = vec_peek(&os);\n        } else {\n          o2.n = 0;\n        }\n      }\n    } else if ((v = expr_var(vars, tok, n)) != NULL) {\n      struct expr var = {(enum expr_type)0};\n      var.type = OP_VAR;\n      var.var.value = &v->value;\n      vec_push(&es, var);\n      paren_next = EXPR_PAREN_FORBIDDEN;\n    } else if (!isspace(*s)) {\n      return NULL; // Bad variable name, e.g. '2.3.4' or '4ever'\n    }\n    paren = paren_next;\n  }\n\n  if (paren == EXPR_PAREN_EXPECTED) {\n    return NULL; // Bad call\n  }\n\n  while (vec_len(&os) > 0) {\n    struct expr_string rest = vec_pop(&os);\n    if (rest.n == 1 && (*rest.s == '(' || *rest.s == ')')) {\n      return NULL; // Bad paren\n    }\n    if (expr_bind(rest.s, rest.n, funcs, &es) == -1) {\n      return NULL;\n    }\n  }\n\n  struct expr *result = (struct expr *)calloc(1, sizeof(struct expr));\n  if (result != NULL) {\n    if (vec_len(&es) == 0) {\n      result->type = OP_CONST;\n    } else {\n      *result = vec_pop(&es);\n    }\n  }\n  vec_free(&os);\n  vec_free(&es);\n  vec_free(&as);\n  return result;\n}\n\nstatic void expr_destroy_args(struct expr *e) {\n  int i;\n  struct expr arg;\n  if (e->type == OP_FUNC) {\n    vec_foreach(&e->func.args, arg, i) { expr_destroy_args(&arg); }\n    vec_free(&e->func.args);\n    if (e->func.context != NULL) {\n      free(e->func.context);\n    }\n  } else if (e->type != OP_CONST && e->type != OP_VAR) {\n    vec_foreach(&e->op.args, arg, i) { expr_destroy_args(&arg); }\n    vec_free(&e->op.args);\n  }\n}\n\nstatic void expr_destroy(struct expr *e, struct expr_var_list *vars) {\n  if (e != NULL) {\n    expr_destroy_args(e);\n    free(e);\n  }\n  if (vars != NULL) {\n    for (struct expr_var *v = vars->head; v;) {\n      struct expr_var *next = v->next;\n      free(v);\n      v = next;\n    }\n  }\n}\n\n#endif /* EXPR_H */\n"]}